# 动态规划
    找出通项公式、递推公式

## 解题步骤
    1、建立状态转移方程
    2、缓存每一步的结果并复用
    3、按顺序求结果，注意边界条件，先求f(0),然后一次往后推

    
## 数据库索引
### 什么是索引
  常见索引结构：
    1.二叉搜索树
    2.有序序列
    3.哈希表  直接读取，

  索引几种实现方式的优缺点：
    1.哈希表：键值对的方式存储，只适用于等值查询，无法区间查询，比如Redis(key-value数据库)，
    2.有序序列：可以区间查询，但增加删除记录新能低，需要每次都挪动数据，一般用于静态数据存储，对静态数据做索引
    3.二叉搜索树：要求是每个节点的左子节点小于父节点，右子节点大于父节点，查询效率较高，事件复杂度O(logN)
    
  mysql 索引类型：
    innodb(B+树)
    myisam(B树也叫B-树)
    B树和B+树的区别
      B树：1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
          （2）子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
          （3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
          （4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;
          B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;
      B+树：
      B树和B+树的区别：
        1.B+树只有叶子结点会存放数据，B树的每个节点都会存放数据
        2.B+树的叶子节点都会通过链表有序连接，能够很快的实现区间查询
        3.B树可以在非叶子节点结束查找，最好的情况是O(1)，但B+树的事件复杂度是O(logN)
        4.B树插入性能比B+树要高
### 创建索引
  普通索引: create index name on tableName(column)
  唯一索引: Unique : create unique index name on tableName
  组件索引: Primary:  alter table tablename add primary key(column)
  联合索引: create index name on tableName(col1,col2)
  删除索引: drop index idx_name on tablename 

Unicode 编码，国际码
中国 GB2312 GBK

全球统一  UTF-8
mysql 里 UTF8MP4
### 建表
CREATE TABLE IF NOT EXISTS `student`(
   `student_id` INT UNSIGNED AUTO_INCREMENT,
   `student_name` VARCHAR(100) NOT NULL,
   `student_sex` VARCHAR(40) NOT NULL,
   `student_age` int(10) NOT NULL,
   `student_date` DATE,
   PRIMARY KEY ( `student_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8MPB4;

### 增删改查
-- 增加
INSERT 语句中指定所有字段名
语法：INSERT INTO 表名（字段名1，字段名2，…）
　　　　　　   VALUES（值1，值2，…）；
举例：INSERT INTO student(id,name,grade)
　　   VALUES(1,'zhangshan',98);
-- 删除 
  即删除指定的部分数据，需要使用WHERE子句来指定删除记录的条件。
  DELETE  FROM student WHERE id=7;

-- 修改
  更新数据指对表中现存的数据进行修改。
  语法：UPDATE 表名 SET 字段名1=值1，[ ，字段名2=值2，…] [ WHERE 条件表达式 ]

-- 查询
1. 简单查询
  SELECT 字段名1，字段名2，… FROM 表名

2. 查询指定的部分字段
  语法：SELECT 字段名1，字段名2，… FROM 表名；

3. 带关系运算符的查询
  语法：SELECT 字段名1，字段名2，… FROM 表名 WHERE 条件表达式
    关系运算符	 说 明
　　　　=	　　　　等于
　　　　<>	　　　不等于
　　　　!=	　　　不等于
　　　　<	　　　　小于
　　　　<=	　　　小于等于
　　　　>	　　　　大于
　　　　>=	　　　大于等于

4. 带 IN 关键字的查询
  IN关键字用于判断某个字段的值是否在指定集合中，若在，则该字段所在的记录将会被查询出来.
  语法：SELECT * | 字段名1，字段名2，… FROM 表名 WHERE 字段名 [ NOT ]  IN （元素1，元素2，…）

5. 带 BETWEEN AND  关键字的查询
  BETWEEN AND 用于判断某个字段的值是否在指定范围之内，若在，则该字段所在的记录会被查询出来，反之不会。
  语法：SELECT * | { 字段名1，字段名2，… } FROM  表名 WHERE 字段名 [ NOT ] BETWEEN  值1  AND  值2；

6. 空值查询
  在数据表中有些值可能为空值（NULL），空值不同于0，也不同于空字符串，需要使用 IS NULL 来判断字段的值是否为空值。
  语法：SELECT * | 字段名1，字段名2，… FROM 表名 WHERE 字段名 IS [ NOT ] NULL

7. 带 DISTINCT 关键字的查询
  很多表中某些字段的数据存在重复的值，可以使用DISTINCT关键字来过滤重复的值，只保留一个值。
  语法：SELECT DISTINCT 字段名 FROM 表名；

8. 带 LIKE 关键字的查询
  语法：SELECT * | 字段名1，字段名2，…　FROM 表名　WHERE 字段名 [ NOT ] LIKE ‘匹配字符串’;
  8.1 百分号（%）通配符
    匹配任意长度的字符串，包括空字符串。例如，字符串“ c% ”匹配以字符 c 开始，任意长度的字符串，如“ ct  ”，“ cut ”，“ current ”等；字符串“ c%g ”表示以字符 c 开始，以 g 结尾的字符串；字符串“ %y% ”表示包含字符“ y ”的字符串，无论“ y ”在字符串的什么位置。
    举例1：查询student2表中name字段以字符“ s ”开头的人的id,name
    命令：SELECT id,name FROM student2  WHERE name LIKE "S%"; 

  8.2 下划线（_）通配符
    下划线通配符只匹配单个字符，若要匹配多个字符，需要使用多个下划线通配符。例如，字符串“ cu_ ”匹配以字符串“ cu ”开始，长度为3的字符，如“ cut ”，“ cup ”；字符串“ c__l”匹配在“ c ”和“ l ”之间包含两个字符的字符串，如“ cool ”。需要注意的是，连续的“_”之间不能有空格，例如“M_ _QL”只能匹配“My SQL”，不能匹配“MySQL”。
    举例：查询在student2表中name字段值以“ wu ”开始，以“ ong ”结束，并且中间只有一个字符的记录。
    命令：SELECT * FROM student2 WHERE name LIKE 'wu_ong';

9. 带 AND 关键字的多条件查询
  在使用SELECT语句查询数据时，优势为了使查询结果更加精确，可以使用多个查询条件，如使用 AND 关键字可以连接两个或多个查询条件。
  语法：SELECT * | 字段名1，字段名2，…　FROM 表名　WHERE 条件表达式1 AND 条件表达式2 [ … AND 条件表达式 n ];

10. 带 OR 关键字的多条件查询
  与 AND 关键字不同，OR 关键字只要满足任意一个条件就会被查询出来
  语法：SELECT * | 字段名1，字段名2，…　FROM 表名　WHERE 条件表达式1 OR 条件表达式2 [ … OR 条件表达式 n ];

11. OR 和 AND 一起使用的情况
  OR 和 AND 一起使用的时候，AND 的优先级高于 OR，因此二者一起使用时，会先运算 AND 两边的表达式，再运算 OR 两边的表达式。
  举例：查询student2表中gender值为“女”或者gender值为“男”并且grade字段值为100的人的记录
  命令：SELECT * FROM student2 WHERE gender='女' OR gender='男' AND grade=100;

12. 高级查询 
1. 聚合函数
 
      函数名称	           作用
　　　　COUNT()	　　　返回某列的行数
　　　　SUM()	　　　　返回某列值的和
　　　　AVG()	　　　　返回某列的平均值
　　　　MAX()	　　　　返回某列的最大值
　　　　MIN()	　　　　返回某列的最小值
  1.1 COUNT()函数：统计记录的条数
      语法：SELECT COUNT(*) FROM 表名

  1.2 SUM()函数：求出表中某个字段所有值的总和
      语法：SELECT  SUM(字段名) FROM 表名；

  1.3 AVG()函数：求出表中某个字段所有值的平均值
      语法：SELECT AVG(字段名) FROM 表名；

  1.4 MAX()函数：求出表中某个字段所有值的最大值
      语法：SELECT MAX(字段名) FROM 表名；

  1.5 MIN()函数：求出表中某个字段所有值的最小值
      语法：SELECT MIN(字段名) FROM 表名；

2. 对查询结果进行排序
  在该语法中指定的字段名是对查询结果进行排序的依据，ASC表示升序排列，DESC 表示降序排列，默认情况是升序排列。
  语法：SELECT 字段名1，字段名2，…　FROM 表名　ORDER BY 字段名1 [ ASC | DESC ],字段名2 [ ASC | DESC ]…

3. 分组查询
  在对表中数据进行统计的时候，可以使用GROUP BY 按某个字段或者多个字段进行分组，字段中值相同的为一组，如男生分为一组，女生分为一组。
  语法：SELECT  字段名1，字段名2，…　FROM 表名　GROUP BY 字段名1，字段名2，… [ HAVING 条件表达式 ];

-- 为表取别名
  在进行查询操作时，如果表名很长使用起来不方便，可以为表取一个别名来代替表的名称。
  语法：SELECT * FROM 表名 [ AS ] 别名；


-- join 连接表
INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。

select stu.name , les.class,les.point from student as stu join lesson as les on stu.lessonid=b.id

## 数据库的三大范式
第一范式：原子性，列不可再分
第二范式：唯一性，每一列都与主键相关
第三范式：独立性，避免字段冗余，不能存在被其他字段推导出的

## 数据库事务
事务就是要保证一组数据库操作要么全部成功，要么全部失败
不是所有的数据库引擎都支持事务，
MyISAM 不支持事务，InnoDB 支持事务

-- 事务的四个特性 ACID
  A 原子性  要么全部成功，要么全部失败
  C 一致性  确保一个事务执行之前和执行之后必须处于一致的状态
  I 隔离性(重要)  一个事务在提交之前是否能够被其他事务可见
  D 持久性  一旦一个事务提交了，那么这个改变就是永久性的

-- 事务隔离级别具有四种：
  1. 读未提交  一个事务还没有提交，其他事务能够看到它做的变更
  2. 读提交    一个事务提交之后，其他事务才能看到变更
  3. 可重复读  一个事务在执行过程中，看到的数据总是跟这个事务在启动时看到的数据一致
  4. 串行化    事务不可并行执行，后访问的事务必须等前一个事务完成才能继续执行

-- 事务的启动方式
  1. 显示启动事务，begin 启动， commit 提交，rollback 回滚 
  2. 程序会自动提交事务 

-- 数据库 锁
    全局锁 表锁 行锁
    1. 全局锁有什么锁，对业务有影响，不能做其他操作，对数据库做全库备份，这种情况只针对没有事务特性的引擎
    2. InnoDB 怎么做备份
      mysqldump 参数 -single transaction，导出数据前启动一个事务，拿到一致性视图，这个过程中，数据库可以正常更新，业务不收影响

    表锁  可以手动触发 lock tables ... read/write 
      特性：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
        1. 读锁
           对于读操作，可以加读锁，一旦数据表加上了读锁，不能加写锁，但是可以多个事务加多个读锁(多个事务同时在读)
        2. 写锁
           对于写操作，一旦加上了写锁，其他事务无法加上读锁和写锁
        3. 元数据锁
           访问一张表的时候自动触发

    行锁
      行锁可以锁一行或者多行记录，InnoDB基于索引实现的 B树不支持行锁
      行锁的特性：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

-- 如果出现死锁怎么办
  1. 死锁检测 发现有死锁出现时，主动回滚某一个事务，让其他事务继续运行
  2. 启用超时机制  如果一定时间内，多个事务进入死锁状态，则全部回滚，后按顺序执行

## 并发事务带来的问题
    相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。

更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题

脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
  A事务读取了B事务未提交的数据，如果B事务发生了回滚，那么A事务读取到的数据就是脏数据

不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。
  A事务在执行过程中，由于A事务比较大，需要长时间多次读取同一条数据，读取到的数据不一致，A事务无法读取到之前的数据了。update操作

幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
  insert 或delete操作
