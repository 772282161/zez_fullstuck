// 方法二：动态规划——最高有效位

// 方法一需要对每个数遍历其二进制表示的每一位。
// 可以换一个思路，当计算 i 的「一比特数」时，如果存在0≤j<i，j 的「一比特数」已知，且 i 和 j相比，
// i 的二进制表示只多了一个 1，
// 则可以快速得到 i 的「一比特数」。令 bits[i] 表示 i 的「一比特数」，则上述关系可以表示成：bits[i]=bits[j]+1。

// 对于正整数 x，如果可以知道最大的正整数 y，使得 y≤x 且 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位是 1，其余都是 0，此时称 y 为 x 的「最高有效位」。
// 令z=x−y，显然 0≤z<x，则 bits[x]=bits[z]+1。

// 为了判断一个正整数是不是 2 的整数次幂， 可以利用方法一中提到的按位与运算的性质。如果正整数 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位是 1，其余都是 0，
// 因此 y&(y−1)=0。由此可见， 正整数 y 是 2 的整数次幂，当且仅当 y&(y−1)=0。

// 显然，0 的「一比特数」为 0。使用 highBit 表示当前的最高有效位， 遍历从 1 到 num 的每个正整数 i，进行如下操作。
// 如果 i&(i−1)=0，则令highBit=i，更新当前的最高有效位。i 比 i−highBit 的「一比特数」多 1，由于是从小到大遍历每个数，
// 因此遍历到 i 时，i−highBit 的「一比特数」已知，令 bits[i]=bits[i−highBit]+1。最终得到的数组 bits 即为答案。

const countBits = function(num){
    const bits=new Array(num+1).fill(0)
    let hightBit=0
    for(let i =1;i<=num;i++){
        if((i&(i-1))==0){
            hightBit=i;
        }
        bits[i]=bits[i-highBit]+1
    }
    return bits
}